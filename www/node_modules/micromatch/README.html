<!DOCTYPE html><html lang="en"><head><meta charset="utf8"/><title></title><script src="/public/dist/bundle.js"></script><link rel="stylesheet" href="/public/scss/main.css"/><link rel="stylesheet" href="/public/scss/bootstrap.min.css"/><link rel="stylesheet" href="/public/scss/icomoon.css"/><link href="https://fonts.googleapis.com/css?family=Roboto:400,700,900,500" rel="stylesheet" type="text/css"/></head><body><nav class="navbar navbar-default"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false" class="navbar-toggle collapsed"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="#" class="navbar-brand">rjmacarthy</a></div><!-- Collect the nav links, forms, and other content for toggling--><div id="bs-example-navbar-collapse-1" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="#">Work with me</a></li></ul></div></div></nav><h1>micromatch <a href="http://badge.fury.io/js/micromatch"><img src="https://badge.fury.io/js/micromatch.svg" alt="NPM version"></a>  <a href="https://travis-ci.org/jonschlinkert/micromatch"><img src="https://travis-ci.org/jonschlinkert/micromatch.svg" alt="Build Status"></a></h1><blockquote>
<p>Glob matching for javascript/node.js. A drop-in replacement and faster alternative to minimatch and multimatch. Just use <code>micromatch.isMatch()</code> instead of <code>minimatch()</code>, or use <code>micromatch()</code> instead of <code>multimatch()</code>.</p>
</blockquote>
<h2>Install</h2><p>Install with <a href="https://www.npmjs.com/">npm</a></p>
<pre><code class="language-sh">$ npm i micromatch --save
</code></pre>
<h2>Table of contents</h2><!-- toc -->
<ul>
<li><a href="#features">Features</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#switch-from-minimatch">Switch from minimatch</a></li>
<li><a href="#methods">Methods</a><ul>
<li><a href="#ismatch">.isMatch</a></li>
<li><a href="#contains">.contains</a></li>
<li><a href="#matcher">.matcher</a></li>
<li><a href="#filter">.filter</a></li>
<li><a href="#any">.any</a></li>
<li><a href="#expand">.expand</a></li>
<li><a href="#makere">.makeRe</a></li>
</ul>
</li>
<li><a href="#options">Options</a><ul>
<li><a href="#optionsunixify">options.unixify</a></li>
<li><a href="#optionsdot">options.dot</a></li>
<li><a href="#optionsunescape">options.unescape</a></li>
<li><a href="#optionsnodupes">options.nodupes</a></li>
<li><a href="#optionsmatchbase">options.matchBase</a></li>
<li><a href="#optionsnobraces">options.nobraces</a></li>
<li><a href="#optionsnobrackets">options.nobrackets</a></li>
<li><a href="#optionsnoextglob">options.noextglob</a></li>
<li><a href="#optionsnocase">options.nocase</a></li>
<li><a href="#optionsnonull">options.nonull</a></li>
<li><a href="#optionscache">options.cache</a></li>
</ul>
</li>
<li><a href="#other-features">Other features</a><ul>
<li><a href="#extended-globbing">Extended globbing</a><ul>
<li><a href="#extglobs">extglobs</a></li>
<li><a href="#brace-expansion">brace expansion</a></li>
<li><a href="#regex-character-classes">regex character classes</a></li>
<li><a href="#regex-groups">regex groups</a></li>
<li><a href="#posix-bracket-expressions">POSIX bracket expressions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#notes">Notes</a></li>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#run-tests">Run tests</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#related">Related</a></li>
<li><a href="#author">Author</a></li>
<li><a href="#license">License</a></li>
</ul>
<p><em>(Table of contents generated by <a href="https://github.com/verbose/verb">verb</a>)</em></p>
<!-- tocstop -->
<h2>Features</h2><p>Micromatch is <a href="#benchmarks">10-55x faster</a> than <a href="https://github.com/isaacs/minimatch">minimatch</a>, resulting from a combination of caching, tokenization, parsing, runtime compilation and regex optimization strategies.</p>
<ul>
<li><a href="#switch-from-minimatch">Drop-in replacement</a> for <a href="https://github.com/isaacs/minimatch">minimatch</a> and <a href="https://github.com/sindresorhus/multimatch">multimatch</a></li>
<li>Built-in support for multiple glob patterns, like <code>[&#39;foo/*.js&#39;, &#39;!bar.js&#39;]</code></li>
<li>Better support for the Bash 4.3 specification, and less buggy</li>
<li>Extensive <a href="./test">unit tests</a> (approx. 1,300 tests). Minimatch fails many of the tests.</li>
</ul>
<p><strong>Mainstream glob features:</strong></p>
<ul>
<li><a href="https://github.com/jonschlinkert/braces">Brace Expansion</a> (<code>foo/bar-{1..5}.md</code>, <code>one/{two,three}/four.md</code>)</li>
<li>Typical glob patterns, like <code>**/*</code>, <code>a/b/*.js</code>, or <code>[&#39;foo/*.js&#39;, &#39;!bar.js&#39;]</code></li>
</ul>
<p><strong>Extended globbing features:</strong></p>
<ul>
<li>Logical <code>OR</code> (<code>foo/bar/(abc|xyz).js</code>)</li>
<li>Regex character classes (<code>foo/bar/baz-[1-5].js</code>)</li>
<li>POSIX <a href="https://github.com/jonschlinkert/expand-brackets">bracket expressions</a> (<code>**/[[:alpha:][:digit:]]/</code>)</li>
<li><a href="https://github.com/jonschlinkert/extglob">extglobs</a> (<code>**/+(x|y)</code>, <code>!(a|b)</code>, etc)</li>
</ul>
<p>You can combine these to create whatever matching patterns you need.</p>
<h2>Usage</h2><pre><code class="language-js">var mm = require(&#39;micromatch&#39;);
mm(array, patterns);
</code></pre>
<p><strong>Examples</strong></p>
<pre><code class="language-js">mm([&#39;a.js&#39;, &#39;b.md&#39;, &#39;c.txt&#39;], &#39;*.{js,txt}&#39;);
//=&gt; [&#39;a.js&#39;, &#39;c.txt&#39;]
</code></pre>
<p><strong>Multiple patterns</strong></p>
<p>Multiple patterns can also be passed:</p>
<pre><code class="language-js">mm([&#39;a.md&#39;, &#39;b.js&#39;, &#39;c.txt&#39;, &#39;d.json&#39;], [&#39;*.md&#39;, &#39;*.txt&#39;]);
//=&gt; [&#39;a.md&#39;, &#39;c.txt&#39;]
</code></pre>
<p><strong>Negation patterns:</strong></p>
<p>Behavior;</p>
<ul>
<li>when the pattern is a string, <a href="https://github.com/isaacs/minimatch">minimatch</a> behavior is used, so patterns are <strong>inclusive by default</strong>.</li>
<li>when an array of patterns is passed, <a href="https://github.com/sindresorhus/multimatch">multimatch</a> behavior is used, so patterns are <strong>exclusive by default</strong></li>
</ul>
<pre><code class="language-js">mm([&#39;a.js&#39;, &#39;b.md&#39;, &#39;c.txt&#39;], &#39;!*.{js,txt}&#39;);
//=&gt; [&#39;b.md&#39;]

mm([&#39;a.md&#39;, &#39;b.js&#39;, &#39;c.txt&#39;, &#39;d.json&#39;], [&#39;*.*&#39;, &#39;!*.{js,txt}&#39;]);
//=&gt; [&#39;a.md&#39;, &#39;d.json&#39;]
</code></pre>
<h2>Switch from minimatch</h2><blockquote>
<p>Use <code>micromatch.isMatch()</code> instead of <code>minimatch()</code></p>
</blockquote>
<p><strong>Minimatch</strong></p>
<p>The main <code>minimatch()</code> function returns true/false for a single file path and pattern:</p>
<pre><code class="language-js">var minimatch = require(&#39;minimatch&#39;);
minimatch(&#39;foo.js&#39;, &#39;*.js&#39;);
//=&gt; &#39;true&#39;
</code></pre>
<p><strong>Micromatch</strong></p>
<p>With micromatch, <code>.isMatch()</code> to get the same result:</p>
<pre><code class="language-js">var mm = require(&#39;micromatch&#39;);
mm.isMatch(&#39;foo.js&#39;, &#39;*.js&#39;);
//=&gt; &#39;true&#39;
</code></pre>
<p>This implementation difference is necessary since the main <code>micromatch()</code> method supports matching on multiple globs, with behavior similar to <a href="https://github.com/sindresorhus/multimatch">multimatch</a>.</p>
<h2>Methods</h2><pre><code class="language-js">var mm = require(&#39;micromatch&#39;);
</code></pre>
<h3>.isMatch</h3><pre><code class="language-js">mm.isMatch(filepath, globPattern);
</code></pre>
<p>Returns true if a file path matches the given glob pattern.</p>
<p><strong>Example</strong></p>
<pre><code class="language-js">mm.isMatch(&#39;.verb.md&#39;, &#39;*.md&#39;);
//=&gt; false

mm.isMatch(&#39;.verb.md&#39;, &#39;*.md&#39;, {dot: true});
//=&gt; true
</code></pre>
<h3>.contains</h3><p>Returns true if any part of a file path matches the given glob pattern. Think of this is &quot;has path&quot; versus &quot;is path&quot;.</p>
<p><strong>Example</strong></p>
<p><code>.isMatch()</code> would return false for both of the following:</p>
<pre><code class="language-js">mm.contains(&#39;a/b/c&#39;, &#39;a/b&#39;);
//=&gt; true

mm.contains(&#39;a/b/c&#39;, &#39;a/*&#39;);
//=&gt; true
</code></pre>
<h3>.matcher</h3><p>Returns a function for matching using the supplied pattern. e.g. create your own &quot;matcher&quot;. The advantage of this method is that the pattern can be compiled outside of a loop.</p>
<p><strong>Pattern</strong></p>
<p>Can be any of the following:</p>
<ul>
<li><code>glob/string</code></li>
<li><code>regex</code></li>
<li><code>function</code></li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="language-js">var isMatch = mm.matcher(&#39;*.md&#39;);
var files = [];

[&#39;a.md&#39;, &#39;b.txt&#39;, &#39;c.md&#39;].forEach(function(fp) {
  if (isMatch(fp)) {
    files.push(fp);
  }
});
</code></pre>
<h3>.filter</h3><p>Returns a function that can be passed to <code>Array#filter()</code>.</p>
<p><strong>Params</strong></p>
<ul>
<li><code>patterns</code> <strong>{String|Array}</strong>:</li>
</ul>
<p><strong>Examples</strong></p>
<p>Single glob:</p>
<pre><code class="language-js">var fn = mm.filter(&#39;*.md&#39;);
[&#39;a.js&#39;, &#39;b.txt&#39;, &#39;c.md&#39;].filter(fn);
//=&gt; [&#39;c.md&#39;]

var fn = mm.filter(&#39;[a-c]&#39;);
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;].filter(fn);
//=&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>Array of glob patterns:</p>
<pre><code class="language-js">var arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];

var fn = mm.filter([&#39;{1..10}&#39;, &#39;![7-9]&#39;, &#39;!{3..4}&#39;]);
arr.filter(fn);
//=&gt; [1, 2, 5, 6, 10]
</code></pre>
<p><em>(Internally this function generates the matching function by using the <a href="#matcher">matcher</a> method. You can use the <a href="#matcher">matcher</a> method directly to create your own filter function)</em></p>
<h3>.any</h3><p>Returns true if a file path matches any of the given patterns.</p>
<pre><code class="language-js">mm.any(filepath, patterns, options);
</code></pre>
<p><strong>Params</strong></p>
<ul>
<li>filepath <code>{String}</code>: The file path to test.</li>
<li>patterns <code>{String|Array}</code>: One or more glob patterns</li>
<li>options: <code>{Object}</code>: options to pass to the <code>.matcher()</code> method.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="language-js">mm.any(&#39;abc&#39;, [&#39;!*z&#39;]);
//=&gt; true
mm.any(&#39;abc&#39;, [&#39;a*&#39;, &#39;z*&#39;]);
//=&gt; true
mm.any(&#39;abc&#39;, &#39;a*&#39;);
//=&gt; true
mm.any(&#39;abc&#39;, [&#39;z*&#39;]);
//=&gt; false
</code></pre>
<h3>.expand</h3><p>Returns an object with a regex-compatible string and tokens.</p>
<pre><code class="language-js">mm.expand(&#39;*.js&#39;);

// when `track` is enabled (for debugging), the `history` array is used
// to record each mutation to the glob pattern as it&#39;s converted to regex
{ options: { track: false, dot: undefined, makeRe: true, negated: false },
  pattern: &#39;(.*\\/|^)bar\\/(?:(?!(?:^|\\/)\\.).)*?&#39;,
  history: [],
  tokens:
   { path:
      { whole: &#39;**/bar/**&#39;,
        dirname: &#39;**/bar/&#39;,
        filename: &#39;**&#39;,
        basename: &#39;**&#39;,
        extname: &#39;&#39;,
        ext: &#39;&#39; },
     is:
      { glob: true,
        negated: false,
        globstar: true,
        dotfile: false,
        dotdir: false },
     match: {},
     original: &#39;**/bar/**&#39;,
     pattern: &#39;**/bar/**&#39;,
     base: &#39;&#39; } }
</code></pre>
<h3>.makeRe</h3><p>Create a regular expression for matching file paths based on the given pattern:</p>
<pre><code class="language-js">mm.makeRe(&#39;*.js&#39;);
//=&gt; /^(?:(?!\.)(?=.)[^/]*?\.js)$/
</code></pre>
<h2>Options</h2><h3>options.unixify</h3><p>Normalize slashes in file paths and glob patterns to forward slashes.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>undefined</code> on non-windows, <code>true</code> on windows.</p>
<h3>options.dot</h3><p>Match dotfiles. Same behavior as <a href="https://github.com/isaacs/minimatch">minimatch</a>.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>false</code></p>
<h3>options.unescape</h3><p>Unescape slashes in glob patterns. Use cautiously, especially on windows.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>undefined</code></p>
<p><strong>Example</strong></p>
<pre><code class="language-js">mm.isMatch(&#39;abc&#39;, &#39;\\a\\b\\c&#39;, {unescape: true});
//=&gt; true
</code></pre>
<h3>options.nodupes</h3><p>Remove duplicate elements from the result array.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>undefined</code></p>
<p><strong>Example</strong></p>
<p>Example of using the <code>unescape</code> and <code>nodupes</code> options together:</p>
<pre><code class="language-js">mm.match([&#39;abc&#39;, &#39;\\a\\b\\c&#39;], &#39;\\a\\b\\c&#39;, {unescape: true});
//=&gt; [&#39;abc&#39;, &#39;abc&#39;]

mm.match([&#39;abc&#39;, &#39;\\a\\b\\c&#39;], &#39;\\a\\b\\c&#39;, {unescape: true, nodupes: true});
//=&gt; [&#39;abc&#39;]
</code></pre>
<h3>options.matchBase</h3><p>Allow glob patterns without slashes to match a file path based on its basename. . Same behavior as <a href="https://github.com/isaacs/minimatch">minimatch</a>.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>false</code></p>
<p><strong>Example</strong></p>
<pre><code class="language-js">mm([&#39;a/b.js&#39;, &#39;a/c.md&#39;], &#39;*.js&#39;);
//=&gt; []

mm([&#39;a/b.js&#39;, &#39;a/c.md&#39;], &#39;*.js&#39;, {matchBase: true});
//=&gt; [&#39;a/b.js&#39;]
</code></pre>
<h3>options.nobraces</h3><p>Don&#39;t expand braces in glob patterns. Same behavior as <a href="https://github.com/isaacs/minimatch">minimatch</a> <code>nobrace</code>.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>undefined</code></p>
<p>See <a href="https://github.com/jonschlinkert/braces">braces</a> for more information about extended brace expansion.</p>
<h3>options.nobrackets</h3><p>Don&#39;t expand POSIX bracket expressions.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>undefined</code></p>
<p>See <a href="https://github.com/jonschlinkert/expand-brackets">expand-brackets</a> for more information about extended bracket expressions.</p>
<h3>options.noextglob</h3><p>Don&#39;t expand extended globs.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>undefined</code></p>
<p>See <a href="https://github.com/jonschlinkert/extglob">extglob</a> for more information about extended globs.</p>
<h3>options.nocase</h3><p>Use a case-insensitive regex for matching files. Same behavior as <a href="https://github.com/isaacs/minimatch">minimatch</a>.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>false</code></p>
<h3>options.nonull</h3><p>If <code>true</code>, when no matches are found the actual (array-ified) glob pattern is returned instead of an empty array. Same behavior as <a href="https://github.com/isaacs/minimatch">minimatch</a>.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>false</code></p>
<h3>options.cache</h3><p>Cache the platform (e.g. <code>win32</code>) to prevent this from being looked up for every filepath.</p>
<p>Type: <code>{Boolean}</code></p>
<p>Default: <code>true</code></p>
<h2>Other features</h2><p>Micromatch also supports the following.</p>
<h3>Extended globbing</h3><h4>extglobs</h4><p>Extended globbing, as described by the bash man page:</p>
<table>
<thead>
<tr>
<th><strong>pattern</strong></th>
<th><strong>regex equivalent</strong></th>
<th><strong>description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?(pattern-list)</code></td>
<td>`(...</td>
<td>...)?`</td>
<td>Matches zero or one occurrence of the given patterns</td>
</tr>
<tr>
<td><code>*(pattern-list)</code></td>
<td>`(...</td>
<td>...)*`</td>
<td>Matches zero or more occurrences of the given patterns</td>
</tr>
<tr>
<td><code>+(pattern-list)</code></td>
<td>`(...</td>
<td>...)+`</td>
<td>Matches one or more occurrences of the given patterns</td>
</tr>
<tr>
<td><code>@(pattern-list)</code></td>
<td>`(...</td>
<td>...)` <sup>*</sup></td>
<td>Matches one of the given patterns</td>
</tr>
<tr>
<td><code>!(pattern-list)</code></td>
<td>N/A</td>
<td>Matches anything except one of the given patterns</td>
</tr>
</tbody>
</table>
<p><sup><strong>*</strong></sup> <code>@</code> isn&#39;t a RegEx character.</p>
<p>Powered by <a href="https://github.com/jonschlinkert/extglob">extglob</a>. Visit that library for the full range of options or to report extglob related issues.</p>
<p>See <a href="https://github.com/jonschlinkert/extglob">extglob</a> for more information about extended globs.</p>
<h4>brace expansion</h4><p>In simple cases, brace expansion appears to work the same way as the logical <code>OR</code> operator. For example, <code>(a|b)</code> will achieve the same result as <code>{a,b}</code>.</p>
<p>Here are some powerful features unique to brace expansion (versus character classes):</p>
<ul>
<li>range expansion: <code>a{1..3}b/*.js</code> expands to: <code>[&#39;a1b/*.js&#39;, &#39;a2b/*.js&#39;, &#39;a3b/*.js&#39;]</code></li>
<li>nesting: <code>a{c,{d,e}}b/*.js</code> expands to: <code>[&#39;acb/*.js&#39;, &#39;adb/*.js&#39;, &#39;aeb/*.js&#39;]</code></li>
</ul>
<p>Visit <a href="https://github.com/jonschlinkert/braces">braces</a> to ask questions and create an issue related to brace-expansion, or to see the full range of features and options related to brace expansion.</p>
<h4>regex character classes</h4><p>With the exception of brace expansion (<code>{a,b}</code>, <code>{1..5}</code>, etc), most of the special characters convert directly to regex, so you can expect them to follow the same rules and produce the same results as regex.</p>
<p>For example, given the list: <code>[&#39;a.js&#39;, &#39;b.js&#39;, &#39;c.js&#39;, &#39;d.js&#39;, &#39;E.js&#39;]</code>:</p>
<ul>
<li><code>[ac].js</code>: matches both <code>a</code> and <code>c</code>, returning <code>[&#39;a.js&#39;, &#39;c.js&#39;]</code></li>
<li><code>[b-d].js</code>: matches from <code>b</code> to <code>d</code>, returning <code>[&#39;b.js&#39;, &#39;c.js&#39;, &#39;d.js&#39;]</code></li>
<li><code>[b-d].js</code>: matches from <code>b</code> to <code>d</code>, returning <code>[&#39;b.js&#39;, &#39;c.js&#39;, &#39;d.js&#39;]</code></li>
<li><code>a/[A-Z].js</code>: matches and uppercase letter, returning <code>[&#39;a/E.md&#39;]</code></li>
</ul>
<p>Learn about <a href="http://www.regular-expressions.info/charclass.html">regex character classes</a>.</p>
<h4>regex groups</h4><p>Given <code>[&#39;a.js&#39;, &#39;b.js&#39;, &#39;c.js&#39;, &#39;d.js&#39;, &#39;E.js&#39;]</code>:</p>
<ul>
<li><code>(a|c).js</code>: would match either <code>a</code> or <code>c</code>, returning <code>[&#39;a.js&#39;, &#39;c.js&#39;]</code></li>
<li><code>(b|d).js</code>: would match either <code>b</code> or <code>d</code>, returning <code>[&#39;b.js&#39;, &#39;d.js&#39;]</code></li>
<li><code>(b|[A-Z]).js</code>: would match either <code>b</code> or an uppercase letter, returning <code>[&#39;b.js&#39;, &#39;E.js&#39;]</code></li>
</ul>
<p>As with regex, parenthese can be nested, so patterns like <code>((a|b)|c)/b</code> will work. But it might be easier to achieve your goal using brace expansion.</p>
<h4>POSIX bracket expressions</h4><p><strong>Example</strong></p>
<pre><code class="language-js">mm.isMatch(&#39;a1&#39;, &#39;[[:alpha:][:digit:]]&#39;);
//=&gt; true
</code></pre>
<p>See <a href="https://github.com/jonschlinkert/expand-brackets">expand-brackets</a> for more information about extended bracket expressions.</p>
<h2>Notes</h2><p>Whenever possible parsing behavior for patterns is based on globbing specifications in Bash 4.3. Patterns that aren&#39;t described by Bash follow wildmatch spec (used by git).</p>
<h2>Benchmarks</h2><p>Run the <a href="./benchmark">benchmarks</a>:</p>
<pre><code class="language-bash">node benchmark
</code></pre>
<p>As of October 03, 2015:</p>
<pre><code class="language-bash">#1: basename-braces
  micromatch x 26,420 ops/sec ±0.89% (91 runs sampled)
  minimatch x 3,507 ops/sec ±0.64% (97 runs sampled)

#2: basename
  micromatch x 25,315 ops/sec ±0.82% (93 runs sampled)
  minimatch x 4,398 ops/sec ±0.86% (94 runs sampled)

#3: braces-no-glob
  micromatch x 341,254 ops/sec ±0.78% (93 runs sampled)
  minimatch x 30,197 ops/sec ±1.12% (91 runs sampled)

#4: braces
  micromatch x 54,649 ops/sec ±0.74% (94 runs sampled)
  minimatch x 3,095 ops/sec ±0.82% (95 runs sampled)

#5: immediate
  micromatch x 16,719 ops/sec ±0.79% (95 runs sampled)
  minimatch x 4,348 ops/sec ±0.86% (96 runs sampled)

#6: large
  micromatch x 721 ops/sec ±0.77% (94 runs sampled)
  minimatch x 17.73 ops/sec ±1.08% (50 runs sampled)

#7: long
  micromatch x 5,051 ops/sec ±0.87% (97 runs sampled)
  minimatch x 628 ops/sec ±0.83% (94 runs sampled)

#8: mid
  micromatch x 51,280 ops/sec ±0.80% (95 runs sampled)
  minimatch x 1,923 ops/sec ±0.84% (95 runs sampled)

#9: multi-patterns
  micromatch x 22,440 ops/sec ±0.97% (94 runs sampled)
  minimatch x 2,481 ops/sec ±1.10% (94 runs sampled)

#10: no-glob
  micromatch x 722,823 ops/sec ±1.30% (87 runs sampled)
  minimatch x 52,967 ops/sec ±1.09% (94 runs sampled)

#11: range
  micromatch x 243,471 ops/sec ±0.79% (94 runs sampled)
  minimatch x 11,736 ops/sec ±0.82% (96 runs sampled)

#12: shallow
  micromatch x 190,874 ops/sec ±0.98% (95 runs sampled)
  minimatch x 21,699 ops/sec ±0.81% (97 runs sampled)

#13: short
  micromatch x 496,393 ops/sec ±3.86% (90 runs sampled)
  minimatch x 53,765 ops/sec ±0.75% (95 runs sampled)
</code></pre>
<h2>Run tests</h2><p>Install dev dependencies:</p>
<pre><code class="language-sh">$ npm i -d &amp;&amp; npm test
</code></pre>
<h2>Contributing</h2><p>Pull requests and stars are always welcome. For bugs and feature requests, <a href="https://github.com/jonschlinkert/micromatch/issues/new">please create an issue</a>.</p>
<p>Please be sure to run the benchmarks before/after any code changes to judge the impact before you do a PR. thanks!</p>
<h2>Related</h2><ul>
<li><a href="https://www.npmjs.com/package/braces">braces</a>: Fastest brace expansion for node.js, with the most complete… <a href="https://www.npmjs.com/package/braces">more</a> | <a href="https://github.com/jonschlinkert/braces">homepage</a></li>
<li><a href="https://www.npmjs.com/package/expand-brackets">expand-brackets</a>: Expand POSIX bracket expressions (character classes) in glob patterns. | <a href="https://github.com/jonschlinkert/expand-brackets">homepage</a></li>
<li><a href="https://www.npmjs.com/package/expand-range">expand-range</a>: Fast, bash-like range expansion. Expand a range of numbers… <a href="https://www.npmjs.com/package/expand-range">more</a> | <a href="https://github.com/jonschlinkert/expand-range">homepage</a></li>
<li><a href="https://www.npmjs.com/package/extglob">extglob</a>: Convert extended globs to regex-compatible strings. Add (almost) the… <a href="https://www.npmjs.com/package/extglob">more</a> | <a href="https://github.com/jonschlinkert/extglob">homepage</a></li>
<li><a href="https://www.npmjs.com/package/fill-range">fill-range</a>: Fill in a range of numbers or letters, optionally… <a href="https://www.npmjs.com/package/fill-range">more</a> | <a href="https://github.com/jonschlinkert/fill-range">homepage</a></li>
<li><a href="https://www.npmjs.com/package/gulp-micromatch">gulp-micromatch</a>: Filter vinyl files with glob patterns, string, regexp, array,… <a href="https://www.npmjs.com/package/gulp-micromatch">more</a> | <a href="https://github.com/tunnckocore/gulp-micromatch">homepage</a></li>
<li><a href="https://www.npmjs.com/package/is-glob">is-glob</a>: Returns <code>true</code> if the given string looks like a… <a href="https://www.npmjs.com/package/is-glob">more</a> | <a href="https://github.com/jonschlinkert/is-glob">homepage</a></li>
<li><a href="https://www.npmjs.com/package/parse-glob">parse-glob</a>: Parse a glob pattern into an object of tokens. | <a href="https://github.com/jonschlinkert/parse-glob">homepage</a></li>
</ul>
<h2>Author</h2><p><strong>Jon Schlinkert</strong></p>
<ul>
<li><a href="https://github.com/jonschlinkert">github/jonschlinkert</a></li>
<li><a href="http://twitter.com/jonschlinkert">twitter/jonschlinkert</a></li>
</ul>
<h2>License</h2><p>Copyright © 2014-2015 <a href="https://github.com/jonschlinkert">Jon Schlinkert</a>
Released under the MIT license.</p>
<hr>
<p><em>This file was generated by <a href="https://github.com/assemble/verb-cli">verb-cli</a> on October 03, 2015.</em></p>
<!-- deps:mocha browserify --><footer><div class="footer"> </div></footer></body></html>