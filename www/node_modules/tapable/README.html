<!DOCTYPE html><html lang="en"><head><meta charset="utf8"/><title></title><script src="/public/dist/bundle.js"></script><link rel="stylesheet" href="/public/scss/main.css"/><link rel="stylesheet" href="/public/scss/bootstrap.min.css"/><link rel="stylesheet" href="/public/scss/icomoon.css"/><link href="https://fonts.googleapis.com/css?family=Roboto:400,700,900,500" rel="stylesheet" type="text/css"/></head><body><nav class="navbar navbar-default"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false" class="navbar-toggle collapsed"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="#" class="navbar-brand">rjmacarthy</a></div><!-- Collect the nav links, forms, and other content for toggling--><div id="bs-example-navbar-collapse-1" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="#">Work with me</a></li></ul></div></div></nav><h1>Tapable</h1><pre><code class="language-javascript">var Tapable = require(&quot;tapable&quot;);
</code></pre>
<p><code>Tapable</code> is a class for plugin binding and applying.</p>
<p>Just extend it.</p>
<pre><code class="language-javascript">function MyClass() {
    Tapable.call(this);
}

MyClass.prototype = Object.create(Tapable.prototype);

MyClass.prototype.method = function() {};
</code></pre>
<p>Or mix it in.</p>
<pre><code class="language-javascript">function MyClass2() {
    EventEmitter.call(this);
    Tapable.call(this);
}

MyClass2.prototype = Object.create(EventEmitter.prototype);
Tapable.mixin(MyClass2.prototype);

MyClass2.prototype.method = function() {};
</code></pre>
<h2>Public functions</h2><h3>apply</h3><pre><code class="language-javascript">void apply(plugins: Plugin...)
</code></pre>
<p>Attaches all plugins passed as arguments to the instance, by calling <code>apply</code> on them.</p>
<h3>plugin</h3><pre><code class="language-javascript">void plugin(names: string|string[], handler: Function)
</code></pre>
<p><code>names</code> are the names (or a single name) of the plugin interfaces the class provides.</p>
<p><code>handler</code> is a callback function. The signature depends on the class. <code>this</code> is the instance of the class.</p>
<h3>restartApplyPlugins</h3><pre><code class="language-javascript">void restartApplyPlugins()
</code></pre>
<p>Should only be called from a handler function.</p>
<p>It restarts the process of applying handers.</p>
<h2>Protected functions</h2><h3>applyPlugins</h3><pre><code class="language-javascript">void applyPlugins(name: string, args: any...)
</code></pre>
<p>Synchronous applies all registered handers for <code>name</code>. The handler functions are called with all args.</p>
<h3>applyPluginsWaterfall</h3><pre><code class="language-javascript">any applyPluginsWaterfall(name: string, init: any, args: any...)
</code></pre>
<p>Synchronous applies all registered handers for <code>name</code>. The handler functions are called with the return value of the previous handler and all args. For the first handler <code>init</code> is used and the return value of the last handler is return by <code>applyPluginsWaterfall</code></p>
<h3>applyPluginsAsync</h3><pre><code class="language-javascript">void applyPluginsAsync(
    name: string,
    args: any...,
    callback: (err?: Error) -&gt; void
)
</code></pre>
<p>Asynchronously applies all registered handers for <code>name</code>. The handler functions are called with all args and a callback function with the signature <code>(err?: Error) -&gt; void</code>. The hander functions are called in order of registration.</p>
<p><code>callback</code> is called after all handlers are called.</p>
<h3>applyPluginsBailResult</h3><pre><code class="language-javascript">any applyPluginsBailResult(name: string, args: any...)
</code></pre>
<p>Synchronous applies all registered handers for <code>name</code>. The handler function are called with all args. If a handler function returns something <code>!== undefined</code>, the value is returned and no more handers are applied.</p>
<h3>applyPluginsAsyncWaterfall</h3><pre><code class="language-javascript">applyPluginsAsyncWaterfall(
    name: string,
    init: any,
    callback: (err: Error, result: any) -&gt; void
)
</code></pre>
<p>Asynchronously applies all registered handers for <code>name</code>. The hander functions are called with the current value and a callback function with the signature <code>(err: Error, nextValue: any) -&gt; void</code>. When called <code>nextValue</code> is the current value for the next handler. The current value for the first handler is <code>init</code>. After all handlers are applied, <code>callback</code> is called with the last value. If any handler passes a value for <code>err</code>, the <code>callback</code> is called with this error and no more handlers are called.</p>
<h3>applyPluginsAsyncSeries</h3><pre><code class="language-javascript">applyPluginsAsyncSeries(
    name: string,
    args: any...,
    callback: (err: Error, result: any) -&gt; void
)
</code></pre>
<p>Asynchronously applies all registered handers for <code>name</code>. The hander functions are called with all <code>args</code> and a callback function with the signature <code>(err: Error) -&gt; void</code>. The handers are called in series, one at a time. After all handlers are applied, <code>callback</code> is called. If any handler passes a value for <code>err</code>, the <code>callback</code> is called with this error and no more handlers are called.</p>
<h3>applyPluginsParallel</h3><pre><code class="language-javascript">applyPluginsParallel(
    name: string,
    args: any...,
    callback: (err?: Error) -&gt; void
)
</code></pre>
<p>Applies all registered handlers for <code>name</code> parallel. The handler functions are called with all args and a callback function with the signature <code>(err?: Error) -&gt; void</code>. The <code>callback</code> function is called when all handlers called the callback without <code>err</code>. If any handler calls the callback with <code>err</code>, <code>callback</code> is invoked with this error and the other handlers are ignored.</p>
<p><code>restartApplyPlugins</code> cannot be used.</p>
<h3>applyPluginsParallelBailResult</h3><pre><code class="language-javascript">applyPluginsParallelBailResult(
    name: string,
    args: any...,
    callback: (err: Error, result: any) -&gt; void
)
</code></pre>
<p>Applies all registered handlers for <code>name</code> parallel. The handler functions are called with all args and a callback function with the signature <code>(err?: Error) -&gt; void</code>. Handler functions must call the callback. They can either pass an error, or pass undefined, or pass an value. The first result (either error or value) with is not undefined is passed to the <code>callback</code>. The order is defined by registeration not by speed of the handler function. This function compentate this.</p>
<p><code>restartApplyPlugins</code> cannot be used.</p><footer><div class="footer"> </div></footer></body></html>