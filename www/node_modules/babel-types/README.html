<!DOCTYPE html><html lang="en"><head><meta charset="utf8"/><title></title><script src="/public/dist/bundle.js"></script><link rel="stylesheet" href="/public/scss/main.css"/><link rel="stylesheet" href="/public/scss/bootstrap.min.css"/><link rel="stylesheet" href="/public/scss/icomoon.css"/><link href="https://fonts.googleapis.com/css?family=Roboto:400,700,900,500" rel="stylesheet" type="text/css"/></head><body><nav class="navbar navbar-default"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false" class="navbar-toggle collapsed"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="#" class="navbar-brand">rjmacarthy</a></div><!-- Collect the nav links, forms, and other content for toggling--><div id="bs-example-navbar-collapse-1" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="#">Work with me</a></li></ul></div></div></nav><h1>babel-types</h1><p>This module contains methods for building ASTs manually and for checking the types of AST nodes.</p>
<h2>API</h2><!-- begin generated section -->
<h3>t.anyTypeAnnotation()</h3><p>See also <code>t.isAnyTypeAnnotation(node, opts)</code> and <code>t.assertAnyTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<h3>t.arrayExpression(elements)</h3><p>See also <code>t.isArrayExpression(node, opts)</code> and <code>t.assertArrayExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>elements</code>: <code>array</code> (required)</li>
</ul>
<h3>t.arrayPattern(elements, typeAnnotation)</h3><p>See also <code>t.isArrayPattern(node, opts)</code> and <code>t.assertArrayPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>elements</code>: <code>Array&lt;Expression&gt;</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<h3>t.arrayTypeAnnotation(elementType)</h3><p>See also <code>t.isArrayTypeAnnotation(node, opts)</code> and <code>t.assertArrayTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>elementType</code> (required)</li>
</ul>
<h3>t.arrowFunctionExpression(params, body, async)</h3><p>See also <code>t.isArrowFunctionExpression(node, opts)</code> and <code>t.assertArrowFunctionExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement | Expression</code> (required)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.assignmentExpression(operator, left, right)</h3><p>See also <code>t.isAssignmentExpression(node, opts)</code> and <code>t.assertAssignmentExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>operator</code>: <code>string</code> (required)</li>
<li><code>left</code>: <code>LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.assignmentPattern(left, right)</h3><p>See also <code>t.isAssignmentPattern(node, opts)</code> and <code>t.assertAssignmentPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>left</code>: <code>Identifier</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.awaitExpression(argument)</h3><p>See also <code>t.isAwaitExpression(node, opts)</code> and <code>t.assertAwaitExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Terminatorless</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.binaryExpression(operator, left, right)</h3><p>See also <code>t.isBinaryExpression(node, opts)</code> and <code>t.assertBinaryExpression(node, opts)</code>.</p>
<p>Aliases: <code>Binary</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code>: <code>string</code> (required)</li>
<li><code>left</code>: <code>Expression</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.bindExpression(object, callee)</h3><p>See also <code>t.isBindExpression(node, opts)</code> and <code>t.assertBindExpression(node, opts)</code>.</p>
<ul>
<li><code>object</code> (required)</li>
<li><code>callee</code> (required)</li>
</ul>
<h3>t.blockStatement(body, directives)</h3><p>See also <code>t.isBlockStatement(node, opts)</code> and <code>t.assertBlockStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>BlockParent</code>, <code>Block</code>, <code>Statement</code></p>
<ul>
<li><code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li>
<li><code>directives</code>: <code>Array&lt;Directive&gt;</code> (default: <code>[]</code>)</li>
</ul>
<h3>t.booleanLiteral(value)</h3><p>See also <code>t.isBooleanLiteral(node, opts)</code> and <code>t.assertBooleanLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>boolean</code> (required)</li>
</ul>
<h3>t.booleanLiteralTypeAnnotation()</h3><p>See also <code>t.isBooleanLiteralTypeAnnotation(node, opts)</code> and <code>t.assertBooleanLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<h3>t.booleanTypeAnnotation()</h3><p>See also <code>t.isBooleanTypeAnnotation(node, opts)</code> and <code>t.assertBooleanTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<h3>t.breakStatement(label)</h3><p>See also <code>t.isBreakStatement(node, opts)</code> and <code>t.assertBreakStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (default: <code>null</code>)</li>
</ul>
<h3>t.callExpression(callee, arguments)</h3><p>See also <code>t.isCallExpression(node, opts)</code> and <code>t.assertCallExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>callee</code>: <code>Expression</code> (required)</li>
<li><code>arguments</code>: <code>array</code> (required)</li>
</ul>
<h3>t.catchClause(param, body)</h3><p>See also <code>t.isCatchClause(node, opts)</code> and <code>t.assertCatchClause(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code></p>
<ul>
<li><code>param</code>: <code>Identifier</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
</ul>
<h3>t.classBody(body)</h3><p>See also <code>t.isClassBody(node, opts)</code> and <code>t.assertClassBody(node, opts)</code>.</p>
<ul>
<li><code>body</code>: <code>Array&lt;ClassMethod&gt;</code> (required)</li>
</ul>
<h3>t.classDeclaration(id, superClass, body, decorators)</h3><p>See also <code>t.isClassDeclaration(node, opts)</code> and <code>t.assertClassDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Class</code>, <code>Statement</code>, <code>Declaration</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (required)</li>
<li><code>superClass</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>ClassBody</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (required)</li>
</ul>
<h3>t.classExpression(id, superClass, body, decorators)</h3><p>See also <code>t.isClassExpression(node, opts)</code> and <code>t.assertClassExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Class</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li>
<li><code>superClass</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>ClassBody</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (required)</li>
</ul>
<h3>t.classImplements(id, typeParameters)</h3><p>See also <code>t.isClassImplements(node, opts)</code> and <code>t.assertClassImplements(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
</ul>
<h3>t.classMethod(kind, key, params, body, computed, static)</h3><p>See also <code>t.isClassMethod(node, opts)</code> and <code>t.assertClassMethod(node, opts)</code>.</p>
<p>Aliases: <code>Function</code>, <code>Scopable</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Method</code></p>
<ul>
<li><code>kind</code>: <code>&quot;get&quot; | &quot;set&quot; | &quot;method&quot; | &quot;constructor&quot;</code> (default: <code>&#39;method&#39;</code>)</li>
<li><code>key</code>if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>static</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.classProperty(key, value, typeAnnotation, decorators)</h3><p>See also <code>t.isClassProperty(node, opts)</code> and <code>t.assertClassProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>Property</code></p>
<ul>
<li><code>key</code> (required)</li>
<li><code>value</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code> (required)</li>
</ul>
<h3>t.conditionalExpression(test, consequent, alternate)</h3><p>See also <code>t.isConditionalExpression(node, opts)</code> and <code>t.assertConditionalExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Conditional</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>consequent</code>: <code>Expression</code> (required)</li>
<li><code>alternate</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.continueStatement(label)</h3><p>See also <code>t.isContinueStatement(node, opts)</code> and <code>t.assertContinueStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (default: <code>null</code>)</li>
</ul>
<h3>t.debuggerStatement()</h3><p>See also <code>t.isDebuggerStatement(node, opts)</code> and <code>t.assertDebuggerStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<h3>t.declareClass(id, typeParameters, extends, body)</h3><p>See also <code>t.isDeclareClass(node, opts)</code> and <code>t.assertDeclareClass(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>extends</code> (required)</li>
<li><code>body</code> (required)</li>
</ul>
<h3>t.declareFunction(id)</h3><p>See also <code>t.isDeclareFunction(node, opts)</code> and <code>t.assertDeclareFunction(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
</ul>
<h3>t.declareModule(id, body)</h3><p>See also <code>t.isDeclareModule(node, opts)</code> and <code>t.assertDeclareModule(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>body</code> (required)</li>
</ul>
<h3>t.declareVariable(id)</h3><p>See also <code>t.isDeclareVariable(node, opts)</code> and <code>t.assertDeclareVariable(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
</ul>
<h3>t.decorator(expression)</h3><p>See also <code>t.isDecorator(node, opts)</code> and <code>t.assertDecorator(node, opts)</code>.</p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.directive(value)</h3><p>See also <code>t.isDirective(node, opts)</code> and <code>t.assertDirective(node, opts)</code>.</p>
<ul>
<li><code>value</code>: <code>DirectiveLiteral</code> (required)</li>
</ul>
<h3>t.directiveLiteral(value)</h3><p>See also <code>t.isDirectiveLiteral(node, opts)</code> and <code>t.assertDirectiveLiteral(node, opts)</code>.</p>
<ul>
<li><code>value</code>: <code>string</code> (required)</li>
</ul>
<h3>t.doExpression(body)</h3><p>See also <code>t.isDoExpression(node, opts)</code> and <code>t.assertDoExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
</ul>
<h3>t.doWhileStatement(test, body)</h3><p>See also <code>t.isDoWhileStatement(node, opts)</code> and <code>t.assertDoWhileStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Loop</code>, <code>While</code>, <code>Scopable</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
</ul>
<h3>t.emptyStatement()</h3><p>See also <code>t.isEmptyStatement(node, opts)</code> and <code>t.assertEmptyStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<h3>t.existentialTypeParam()</h3><p>See also <code>t.isExistentialTypeParam(node, opts)</code> and <code>t.assertExistentialTypeParam(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<h3>t.exportAllDeclaration(source)</h3><p>See also <code>t.isExportAllDeclaration(node, opts)</code> and <code>t.assertExportAllDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>source</code> (required)</li>
</ul>
<h3>t.exportDefaultDeclaration(declaration)</h3><p>See also <code>t.isExportDefaultDeclaration(node, opts)</code> and <code>t.assertExportDefaultDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>declaration</code> (required)</li>
</ul>
<h3>t.exportDefaultSpecifier(exported)</h3><p>See also <code>t.isExportDefaultSpecifier(node, opts)</code> and <code>t.assertExportDefaultSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>exported</code>: <code>Identifier</code> (required)</li>
</ul>
<h3>t.exportNamedDeclaration(declaration, specifiers, source)</h3><p>See also <code>t.isExportNamedDeclaration(node, opts)</code> and <code>t.assertExportNamedDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>declaration</code> (required)</li>
<li><code>specifiers</code> (required)</li>
<li><code>source</code> (required)</li>
</ul>
<h3>t.exportNamespaceSpecifier(exported)</h3><p>See also <code>t.isExportNamespaceSpecifier(node, opts)</code> and <code>t.assertExportNamespaceSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>exported</code>: <code>Identifier</code> (required)</li>
</ul>
<h3>t.exportSpecifier(local, exported)</h3><p>See also <code>t.isExportSpecifier(node, opts)</code> and <code>t.assertExportSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
<li><code>exported</code> (required)</li>
</ul>
<h3>t.expressionStatement(expression)</h3><p>See also <code>t.isExpressionStatement(node, opts)</code> and <code>t.assertExpressionStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>ExpressionWrapper</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.file(program, comments, tokens)</h3><p>See also <code>t.isFile(node, opts)</code> and <code>t.assertFile(node, opts)</code>.</p>
<ul>
<li><code>program</code>: <code>Program</code> (required)</li>
<li><code>comments</code> (required)</li>
<li><code>tokens</code> (required)</li>
</ul>
<h3>t.forInStatement(left, right, body)</h3><p>See also <code>t.isForInStatement(node, opts)</code> and <code>t.assertForInStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code>, <code>ForXStatement</code></p>
<ul>
<li><code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<h3>t.forOfStatement(left, right, body)</h3><p>See also <code>t.isForOfStatement(node, opts)</code> and <code>t.assertForOfStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code>, <code>ForXStatement</code></p>
<ul>
<li><code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<h3>t.forStatement(init, test, update, body)</h3><p>See also <code>t.isForStatement(node, opts)</code> and <code>t.assertForStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code></p>
<ul>
<li><code>init</code>: <code>VariableDeclaration | Expression</code> (default: <code>null</code>)</li>
<li><code>test</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>update</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<h3>t.functionDeclaration(id, params, body, generator, async)</h3><p>See also <code>t.isFunctionDeclaration(node, opts)</code> and <code>t.assertFunctionDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Statement</code>, <code>Pureish</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (required)</li>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.functionExpression(id, params, body, generator, async)</h3><p>See also <code>t.isFunctionExpression(node, opts)</code> and <code>t.assertFunctionExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.functionTypeAnnotation(typeParameters, params, rest, returnType)</h3><p>See also <code>t.isFunctionTypeAnnotation(node, opts)</code> and <code>t.assertFunctionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeParameters</code> (required)</li>
<li><code>params</code> (required)</li>
<li><code>rest</code> (required)</li>
<li><code>returnType</code> (required)</li>
</ul>
<h3>t.functionTypeParam(name, typeAnnotation)</h3><p>See also <code>t.isFunctionTypeParam(node, opts)</code> and <code>t.assertFunctionTypeParam(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>name</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<h3>t.genericTypeAnnotation(id, typeParameters)</h3><p>See also <code>t.isGenericTypeAnnotation(node, opts)</code> and <code>t.assertGenericTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
</ul>
<h3>t.identifier(name)</h3><p>See also <code>t.isIdentifier(node, opts)</code> and <code>t.assertIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>LVal</code></p>
<ul>
<li><code>name``string</code> (required)</li>
</ul>
<h3>t.ifStatement(test, consequent, alternate)</h3><p>See also <code>t.isIfStatement(node, opts)</code> and <code>t.assertIfStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Conditional</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>consequent</code>: <code>Statement</code> (default: <code>null</code>)</li>
<li><code>alternate</code>: <code>Statement</code> (default: <code>null</code>)</li>
</ul>
<h3>t.importDeclaration(specifiers, source)</h3><p>See also <code>t.isImportDeclaration(node, opts)</code> and <code>t.assertImportDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code></p>
<ul>
<li><code>specifiers</code>: <code>Array&lt;ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier&gt;</code> (required)</li>
<li><code>source</code>: <code>StringLiteral</code> (required)</li>
</ul>
<h3>t.importDefaultSpecifier(local)</h3><p>See also <code>t.isImportDefaultSpecifier(node, opts)</code> and <code>t.assertImportDefaultSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
</ul>
<h3>t.importNamespaceSpecifier(local)</h3><p>See also <code>t.isImportNamespaceSpecifier(node, opts)</code> and <code>t.assertImportNamespaceSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
</ul>
<h3>t.importSpecifier(local, imported)</h3><p>See also <code>t.isImportSpecifier(node, opts)</code> and <code>t.assertImportSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
<li><code>imported</code>: <code>Identifier</code> (required)</li>
</ul>
<h3>t.interfaceDeclaration(id, typeParameters, extends, body)</h3><p>See also <code>t.isInterfaceDeclaration(node, opts)</code> and <code>t.assertInterfaceDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>extends</code> (required)</li>
<li><code>body</code> (required)</li>
</ul>
<h3>t.interfaceExtends(id, typeParameters)</h3><p>See also <code>t.isInterfaceExtends(node, opts)</code> and <code>t.assertInterfaceExtends(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
</ul>
<h3>t.intersectionTypeAnnotation(types)</h3><p>See also <code>t.isIntersectionTypeAnnotation(node, opts)</code> and <code>t.assertIntersectionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required)</li>
</ul>
<h3>t.jSXAttribute(name, value)</h3><p>See also <code>t.isJSXAttribute(node, opts)</code> and <code>t.assertJSXAttribute(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXMemberExpression</code> (required)</li>
<li><code>value</code>: <code>JSXElement | StringLiteral | JSXExpressionContainer</code> (default: <code>null</code>)</li>
</ul>
<h3>t.jSXClosingElement(name)</h3><p>See also <code>t.isJSXClosingElement(node, opts)</code> and <code>t.assertJSXClosingElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXMemberExpression</code> (required)</li>
</ul>
<h3>t.jSXElement(openingElement, closingElement, children, selfClosing)</h3><p>See also <code>t.isJSXElement(node, opts)</code> and <code>t.assertJSXElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code>, <code>Expression</code></p>
<ul>
<li><code>openingElement</code>: <code>JSXOpeningElement</code> (required)</li>
<li><code>closingElement</code>: <code>JSXClosingElement</code> (default: <code>null</code>)</li>
<li><code>children</code> (required)</li>
<li><code>selfClosing</code> (required)</li>
</ul>
<h3>t.jSXEmptyExpression()</h3><p>See also <code>t.isJSXEmptyExpression(node, opts)</code> and <code>t.assertJSXEmptyExpression(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<h3>t.jSXExpressionContainer(expression)</h3><p>See also <code>t.isJSXExpressionContainer(node, opts)</code> and <code>t.assertJSXExpressionContainer(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.jSXIdentifier(name)</h3><p>See also <code>t.isJSXIdentifier(node, opts)</code> and <code>t.assertJSXIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<ul>
<li><code>name</code>: <code>string</code> (required)</li>
</ul>
<h3>t.jSXMemberExpression(object, property)</h3><p>See also <code>t.isJSXMemberExpression(node, opts)</code> and <code>t.assertJSXMemberExpression(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<ul>
<li><code>object</code>: <code>JSXIdentifier</code> (required)</li>
<li><code>property</code>: <code>JSXIdentifier</code> (required)</li>
</ul>
<h3>t.jSXNamespacedName(namespace, name)</h3><p>See also <code>t.isJSXNamespacedName(node, opts)</code> and <code>t.assertJSXNamespacedName(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code></p>
<ul>
<li><code>namespace</code>: <code>JSXIdentifier</code> (required)</li>
<li><code>name</code>: <code>JSXIdentifier</code> (required)</li>
</ul>
<h3>t.jSXOpeningElement(name, attributes, selfClosing)</h3><p>See also <code>t.isJSXOpeningElement(node, opts)</code> and <code>t.assertJSXOpeningElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXMemberExpression</code> (required)</li>
<li><code>attributes</code>: <code>Array&lt;JSXAttribute | JSXSpreadAttribute&gt;</code> (required)</li>
<li><code>selfClosing</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.jSXSpreadAttribute(argument)</h3><p>See also <code>t.isJSXSpreadAttribute(node, opts)</code> and <code>t.assertJSXSpreadAttribute(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.jSXText(value)</h3><p>See also <code>t.isJSXText(node, opts)</code> and <code>t.assertJSXText(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code></p>
<ul>
<li><code>value</code>: <code>string</code> (required)</li>
</ul>
<h3>t.labeledStatement(label, body)</h3><p>See also <code>t.isLabeledStatement(node, opts)</code> and <code>t.assertLabeledStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<h3>t.logicalExpression(operator, left, right)</h3><p>See also <code>t.isLogicalExpression(node, opts)</code> and <code>t.assertLogicalExpression(node, opts)</code>.</p>
<p>Aliases: <code>Binary</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code> (required)</li>
<li><code>left</code>: <code>Expression</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.memberExpression(object, property, computed)</h3><p>See also <code>t.isMemberExpression(node, opts)</code> and <code>t.assertMemberExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>LVal</code></p>
<ul>
<li><code>object</code>: <code>Expression</code> (required)</li>
<li><code>property</code>if computed then <code>Expression</code> else <code>Identifier</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.metaProperty(meta, property)</h3><p>See also <code>t.isMetaProperty(node, opts)</code> and <code>t.assertMetaProperty(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>meta</code>: <code>string</code> (required)</li>
<li><code>property</code>: <code>string</code> (required)</li>
</ul>
<h3>t.mixedTypeAnnotation()</h3><p>See also <code>t.isMixedTypeAnnotation(node, opts)</code> and <code>t.assertMixedTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<h3>t.newExpression(callee, arguments)</h3><p>See also <code>t.isNewExpression(node, opts)</code> and <code>t.assertNewExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>callee</code>: <code>Expression</code> (required)</li>
<li><code>arguments</code>: <code>Array&lt;Expression&gt;</code> (required)</li>
</ul>
<h3>t.noop()</h3><p>See also <code>t.isNoop(node, opts)</code> and <code>t.assertNoop(node, opts)</code>.</p>
<h3>t.nullLiteral()</h3><p>See also <code>t.isNullLiteral(node, opts)</code> and <code>t.assertNullLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<h3>t.nullableTypeAnnotation(typeAnnotation)</h3><p>See also <code>t.isNullableTypeAnnotation(node, opts)</code> and <code>t.assertNullableTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<h3>t.numberTypeAnnotation()</h3><p>See also <code>t.isNumberTypeAnnotation(node, opts)</code> and <code>t.assertNumberTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<h3>t.numericLiteral(value)</h3><p>See also <code>t.isNumericLiteral(node, opts)</code> and <code>t.assertNumericLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>number</code> (required)</li>
</ul>
<h3>t.numericLiteralTypeAnnotation()</h3><p>See also <code>t.isNumericLiteralTypeAnnotation(node, opts)</code> and <code>t.assertNumericLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<h3>t.objectExpression(properties)</h3><p>See also <code>t.isObjectExpression(node, opts)</code> and <code>t.assertObjectExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>properties</code>: <code>Array&lt;ObjectMethod | ObjectProperty | SpreadProperty&gt;</code> (required)</li>
</ul>
<h3>t.objectMethod(kind, key, params, body, computed)</h3><p>See also <code>t.isObjectMethod(node, opts)</code> and <code>t.assertObjectMethod(node, opts)</code>.</p>
<p>Aliases: <code>UserWhitespacable</code>, <code>Function</code>, <code>Scopable</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Method</code></p>
<ul>
<li><code>kind</code>: <code>&quot;method&quot; | &quot;get&quot; | &quot;set&quot;</code> (default: <code>&#39;method&#39;</code>)</li>
<li><code>key</code>if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li>
<li><code>params</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.objectPattern(properties, typeAnnotation)</h3><p>See also <code>t.isObjectPattern(node, opts)</code> and <code>t.assertObjectPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>properties</code>: <code>Array&lt;RestProperty&gt;</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<h3>t.objectProperty(key, value, computed, shorthand, decorators)</h3><p>See also <code>t.isObjectProperty(node, opts)</code> and <code>t.assertObjectProperty(node, opts)</code>.</p>
<p>Aliases: <code>UserWhitespacable</code>, <code>Property</code></p>
<ul>
<li><code>key</code>if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li>
<li><code>value</code>: <code>Expression</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>shorthand</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
</ul>
<h3>t.objectTypeAnnotation(properties, indexers, callProperties)</h3><p>See also <code>t.isObjectTypeAnnotation(node, opts)</code> and <code>t.assertObjectTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>properties</code> (required)</li>
<li><code>indexers</code> (required)</li>
<li><code>callProperties</code> (required)</li>
</ul>
<h3>t.objectTypeCallProperty(value)</h3><p>See also <code>t.isObjectTypeCallProperty(node, opts)</code> and <code>t.assertObjectTypeCallProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>value</code> (required)</li>
</ul>
<h3>t.objectTypeIndexer(id, key, value)</h3><p>See also <code>t.isObjectTypeIndexer(node, opts)</code> and <code>t.assertObjectTypeIndexer(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>key</code> (required)</li>
<li><code>value</code> (required)</li>
</ul>
<h3>t.objectTypeProperty(key, value)</h3><p>See also <code>t.isObjectTypeProperty(node, opts)</code> and <code>t.assertObjectTypeProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>key</code> (required)</li>
<li><code>value</code> (required)</li>
</ul>
<h3>t.parenthesizedExpression(expression)</h3><p>See also <code>t.isParenthesizedExpression(node, opts)</code> and <code>t.assertParenthesizedExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>ExpressionWrapper</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.program(body, directives)</h3><p>See also <code>t.isProgram(node, opts)</code> and <code>t.assertProgram(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>BlockParent</code>, <code>Block</code>, <code>FunctionParent</code></p>
<ul>
<li><code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li>
<li><code>directives</code>: <code>Array&lt;Directive&gt;</code> (default: <code>[]</code>)</li>
</ul>
<h3>t.qualifiedTypeIdentifier(id, qualification)</h3><p>See also <code>t.isQualifiedTypeIdentifier(node, opts)</code> and <code>t.assertQualifiedTypeIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>qualification</code> (required)</li>
</ul>
<h3>t.regExpLiteral(pattern, flags)</h3><p>See also <code>t.isRegExpLiteral(node, opts)</code> and <code>t.assertRegExpLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Literal</code></p>
<ul>
<li><code>pattern</code>: <code>string</code> (required)</li>
<li><code>flags</code>: <code>string</code> (default: <code>&#39;&#39;</code>)</li>
</ul>
<h3>t.restElement(argument, typeAnnotation)</h3><p>See also <code>t.isRestElement(node, opts)</code> and <code>t.assertRestElement(node, opts)</code>.</p>
<p>Aliases: <code>LVal</code></p>
<ul>
<li><code>argument</code>: <code>LVal</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<h3>t.restProperty(argument)</h3><p>See also <code>t.isRestProperty(node, opts)</code> and <code>t.assertRestProperty(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>LVal</code> (required)</li>
</ul>
<h3>t.returnStatement(argument)</h3><p>See also <code>t.isReturnStatement(node, opts)</code> and <code>t.assertReturnStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (default: <code>null</code>)</li>
</ul>
<h3>t.sequenceExpression(expressions)</h3><p>See also <code>t.isSequenceExpression(node, opts)</code> and <code>t.assertSequenceExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>expressions</code>: <code>array</code> (required)</li>
</ul>
<h3>t.spreadElement(argument)</h3><p>See also <code>t.isSpreadElement(node, opts)</code> and <code>t.assertSpreadElement(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.spreadProperty(argument)</h3><p>See also <code>t.isSpreadProperty(node, opts)</code> and <code>t.assertSpreadProperty(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.stringLiteral(value)</h3><p>See also <code>t.isStringLiteral(node, opts)</code> and <code>t.assertStringLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>string</code> (required)</li>
</ul>
<h3>t.stringLiteralTypeAnnotation()</h3><p>See also <code>t.isStringLiteralTypeAnnotation(node, opts)</code> and <code>t.assertStringLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<h3>t.stringTypeAnnotation()</h3><p>See also <code>t.isStringTypeAnnotation(node, opts)</code> and <code>t.assertStringTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<h3>t.super()</h3><p>See also <code>t.isSuper(node, opts)</code> and <code>t.assertSuper(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<h3>t.switchCase(test, consequent)</h3><p>See also <code>t.isSwitchCase(node, opts)</code> and <code>t.assertSwitchCase(node, opts)</code>.</p>
<ul>
<li><code>test</code> (required)</li>
<li><code>consequent</code> (required)</li>
</ul>
<h3>t.switchStatement(discriminant, cases)</h3><p>See also <code>t.isSwitchStatement(node, opts)</code> and <code>t.assertSwitchStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Scopable</code></p>
<ul>
<li><code>discriminant</code> (required)</li>
<li><code>cases</code> (required)</li>
</ul>
<h3>t.taggedTemplateExpression(tag, quasi)</h3><p>See also <code>t.isTaggedTemplateExpression(node, opts)</code> and <code>t.assertTaggedTemplateExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>tag</code>: <code>Expression</code> (required)</li>
<li><code>quasi</code>: <code>TemplateLiteral</code> (required)</li>
</ul>
<h3>t.templateElement(value, tail)</h3><p>See also <code>t.isTemplateElement(node, opts)</code> and <code>t.assertTemplateElement(node, opts)</code>.</p>
<ul>
<li><code>value</code> (required)</li>
<li><code>tail</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.templateLiteral(quasis, expressions)</h3><p>See also <code>t.isTemplateLiteral(node, opts)</code> and <code>t.assertTemplateLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Literal</code></p>
<ul>
<li><code>quasis</code> (required)</li>
<li><code>expressions</code> (required)</li>
</ul>
<h3>t.thisExpression()</h3><p>See also <code>t.isThisExpression(node, opts)</code> and <code>t.assertThisExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<h3>t.throwStatement(argument)</h3><p>See also <code>t.isThrowStatement(node, opts)</code> and <code>t.assertThrowStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<h3>t.tryStatement(block, handler, finalizer)</h3><p>See also <code>t.isTryStatement(node, opts)</code> and <code>t.assertTryStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>block</code> (required)</li>
<li><code>handler</code> (default: <code>null</code>)</li>
<li><code>finalizer</code>: <code>BlockStatement</code> (default: <code>null</code>)</li>
</ul>
<h3>t.tupleTypeAnnotation(types)</h3><p>See also <code>t.isTupleTypeAnnotation(node, opts)</code> and <code>t.assertTupleTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required)</li>
</ul>
<h3>t.typeAlias(id, typeParameters, right)</h3><p>See also <code>t.isTypeAlias(node, opts)</code> and <code>t.assertTypeAlias(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>right</code> (required)</li>
</ul>
<h3>t.typeAnnotation(typeAnnotation)</h3><p>See also <code>t.isTypeAnnotation(node, opts)</code> and <code>t.assertTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<h3>t.typeCastExpression(expression, typeAnnotation)</h3><p>See also <code>t.isTypeCastExpression(node, opts)</code> and <code>t.assertTypeCastExpression(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>ExpressionWrapper</code></p>
<ul>
<li><code>expression</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<h3>t.typeParameterDeclaration(params)</h3><p>See also <code>t.isTypeParameterDeclaration(node, opts)</code> and <code>t.assertTypeParameterDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>params</code> (required)</li>
</ul>
<h3>t.typeParameterInstantiation(params)</h3><p>See also <code>t.isTypeParameterInstantiation(node, opts)</code> and <code>t.assertTypeParameterInstantiation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>params</code> (required)</li>
</ul>
<h3>t.typeofTypeAnnotation(argument)</h3><p>See also <code>t.isTypeofTypeAnnotation(node, opts)</code> and <code>t.assertTypeofTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>argument</code> (required)</li>
</ul>
<h3>t.unaryExpression(operator, argument, prefix)</h3><p>See also <code>t.isUnaryExpression(node, opts)</code> and <code>t.assertUnaryExpression(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code> (required)</li>
<li><code>argument</code>: <code>Expression</code> (required)</li>
<li><code>prefix</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.unionTypeAnnotation(types)</h3><p>See also <code>t.isUnionTypeAnnotation(node, opts)</code> and <code>t.assertUnionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required)</li>
</ul>
<h3>t.updateExpression(operator, argument, prefix)</h3><p>See also <code>t.isUpdateExpression(node, opts)</code> and <code>t.assertUpdateExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>operator</code> (required)</li>
<li><code>argument</code>: <code>Expression</code> (required)</li>
<li><code>prefix</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<h3>t.variableDeclaration(kind, declarations)</h3><p>See also <code>t.isVariableDeclaration(node, opts)</code> and <code>t.assertVariableDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>kind</code>: <code>&quot;var&quot; | &quot;let&quot; | &quot;const&quot;</code> (required)</li>
<li><code>declarations</code>: <code>Array&lt;VariableDeclarator&gt;</code> (required)</li>
</ul>
<h3>t.variableDeclarator(id, init)</h3><p>See also <code>t.isVariableDeclarator(node, opts)</code> and <code>t.assertVariableDeclarator(node, opts)</code>.</p>
<ul>
<li><code>id</code>: <code>LVal</code> (required)</li>
<li><code>init</code>: <code>Expression</code> (default: <code>null</code>)</li>
</ul>
<h3>t.voidTypeAnnotation()</h3><p>See also <code>t.isVoidTypeAnnotation(node, opts)</code> and <code>t.assertVoidTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<h3>t.whileStatement(test, body)</h3><p>See also <code>t.isWhileStatement(node, opts)</code> and <code>t.assertWhileStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Loop</code>, <code>While</code>, <code>Scopable</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>BlockStatement | Statement</code> (required)</li>
</ul>
<h3>t.withStatement(object, body)</h3><p>See also <code>t.isWithStatement(node, opts)</code> and <code>t.assertWithStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>object</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
</ul>
<h3>t.yieldExpression(argument, delegate)</h3><p>See also <code>t.isYieldExpression(node, opts)</code> and <code>t.assertYieldExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Terminatorless</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>delegate</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<!-- end generated section --><footer><div class="footer"> </div></footer></body></html>