<!DOCTYPE html><html lang="en"><head><meta charset="utf8"/><title></title><script src="/public/dist/bundle.js"></script><link rel="stylesheet" href="/public/scss/main.css"/><link rel="stylesheet" href="/public/scss/bootstrap.min.css"/><link rel="stylesheet" href="/public/scss/icomoon.css"/><link href="https://fonts.googleapis.com/css?family=Roboto:400,700,900,500" rel="stylesheet" type="text/css"/></head><body><nav class="navbar navbar-default"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false" class="navbar-toggle collapsed"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="#" class="navbar-brand">rjmacarthy</a></div><!-- Collect the nav links, forms, and other content for toggling--><div id="bs-example-navbar-collapse-1" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="#">Work with me</a></li></ul></div></div></nav><h1>private <a href="https://travis-ci.org/benjamn/private"><img src="https://travis-ci.org/benjamn/private.png?branch=master" alt="Build Status"></a></h1><p>A general-purpose utility for associating truly private state with any JavaScript object.</p>
<h2>Installation</h2><p>From NPM:</p>
<pre><code>npm install private
</code></pre><p>From GitHub:</p>
<pre><code>cd path/to/node_modules
git clone git://github.com/benjamn/private.git
cd private
npm install .
</code></pre><h2>Usage</h2><p><strong>Get or create a secret object associated with any (non-frozen) object:</strong></p>
<pre><code class="language-js">var getSecret = require(&quot;private&quot;).makeAccessor();
var obj = Object.create(null); // any kind of object works
getSecret(obj).totallySafeProperty = &quot;p455w0rd&quot;;

console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []
console.log(getSecret(obj)); // { totallySafeProperty: &quot;p455w0rd&quot; }
</code></pre>
<p>Now, only code that has a reference to both <code>getSecret</code> and <code>obj</code> can possibly access <code>.totallySafeProperty</code>.</p>
<p><em>Importantly, no global references to the secret object are retained by the <code>private</code> package, so as soon as <code>obj</code> gets garbage collected, the secret will be reclaimed as well. In other words, you don&#39;t have to worry about memory leaks.</em></p>
<p><strong>Create a unique property name that cannot be enumerated or guessed:</strong></p>
<pre><code class="language-js">var secretKey = require(&quot;private&quot;).makeUniqueKey();
var obj = Object.create(null); // any kind of object works

Object.defineProperty(obj, secretKey, {
  value: { totallySafeProperty: &quot;p455w0rd&quot; },
  enumerable: false // optional; non-enumerability is the default
});

Object.defineProperty(obj, &quot;nonEnumerableProperty&quot;, {
  value: &quot;anyone can guess my name&quot;,
  enumerable: false
});

console.log(obj[secretKey].totallySafeProperty); // p455w0rd
console.log(obj.nonEnumerableProperty); // &quot;anyone can guess my name&quot;
console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // [&quot;nonEnumerableProperty&quot;]

for (var key in obj) {
  console.log(key); // never called
}
</code></pre>
<p>Because these keys are non-enumerable, you can&#39;t discover them using a <code>for</code>-<code>in</code> loop. Because <code>secretKey</code> is a long string of random characters, you would have a lot of trouble guessing it. And because the <code>private</code> module wraps <code>Object.getOwnPropertyNames</code> to exclude the keys it generates, you can&#39;t even use that interface to discover it.</p>
<p>Unless you have access to the value of the <code>secretKey</code> property name, there is no way to access the value associated with it. So your only responsibility as secret-keeper is to avoid handing out the value of <code>secretKey</code> to untrusted code.</p>
<p>Think of this style as a home-grown version of the first style. Note, however, that it requires a full implementation of ES5&#39;s <code>Object.defineProperty</code> method in order to make any safety guarantees, whereas the first example will provide safety even in environments that do not support <code>Object.defineProperty</code>.</p>
<h2>Rationale</h2><p>In JavaScript, the only data that are truly private are local variables
whose values do not <em>leak</em> from the scope in which they were defined.</p>
<p>This notion of <em>closure privacy</em> is powerful, and it readily provides some
of the benefits of traditional data privacy, a la Java or C++:</p>
<pre><code class="language-js">function MyClass(secret) {
    this.increment = function() {
        return ++secret;
    };
}

var mc = new MyClass(3);
console.log(mc.increment()); // 4
</code></pre>
<p>You can learn something about <code>secret</code> by calling <code>.increment()</code>, and you
can increase its value by one as many times as you like, but you can never
decrease its value, because it is completely inaccessible except through
the <code>.increment</code> method. And if the <code>.increment</code> method were not
available, it would be as if no <code>secret</code> variable had ever been declared,
as far as you could tell.</p>
<p>This style breaks down as soon as you want to inherit methods from the
prototype of a class:</p>
<pre><code class="language-js">function MyClass(secret) {
    this.secret = secret;
}

MyClass.prototype.increment = function() {
    return ++this.secret;
};
</code></pre>
<p>The only way to communicate between the <code>MyClass</code> constructor and the
<code>.increment</code> method in this example is to manipulate shared properties of
<code>this</code>. Unfortunately <code>this.secret</code> is now exposed to unlicensed
modification:</p>
<pre><code class="language-js">var mc = new MyClass(6);
console.log(mc.increment()); // 7
mc.secret -= Infinity;
console.log(mc.increment()); // -Infinity
mc.secret = &quot;Go home JavaScript, you&#39;re drunk.&quot;;
mc.increment(); // NaN
</code></pre>
<p>Another problem with closure privacy is that it only lends itself to
per-instance privacy, whereas the <code>private</code> keyword in most
object-oriented languages indicates that the data member in question is
visible to all instances of the same class.</p>
<p>Suppose you have a <code>Node</code> class with a notion of parents and children:</p>
<pre><code class="language-js">function Node() {
    var parent;
    var children = [];

    this.getParent = function() {
        return parent;
    };

    this.appendChild = function(child) {
        children.push(child);
        child.parent = this; // Can this be made to work?
    };
}
</code></pre>
<p>The desire here is to allow other <code>Node</code> objects to manipulate the value
returned by <code>.getParent()</code>, but otherwise disallow any modification of the
<code>parent</code> variable. You could expose a <code>.setParent</code> function, but then
anyone could call it, and you might as well give up on the getter/setter
pattern.</p>
<p>This module solves both of these problems.</p>
<h2>Usage</h2><p>Let&#39;s revisit the <code>Node</code> example from above:</p>
<pre><code class="language-js">var p = require(&quot;private&quot;).makeAccessor();

function Node() {
    var privates = p(this);
    var children = [];

    this.getParent = function() {
        return privates.parent;
    };

    this.appendChild = function(child) {
        children.push(child);
        var cp = p(child);
        if (cp.parent)
            cp.parent.removeChild(child);
        cp.parent = this;
        return child;
    };
}
</code></pre>
<p>Now, in order to access the private data of a <code>Node</code> object, you need to
have access to the unique <code>p</code> function that is being used here.  This is
already an improvement over the previous example, because it allows
restricted access by other <code>Node</code> instances, but can it help with the
<code>Node.prototype</code> problem too?</p>
<p>Yes it can!</p>
<pre><code class="language-js">var p = require(&quot;private&quot;).makeAccessor();

function Node() {
    p(this).children = [];
}

var Np = Node.prototype;

Np.getParent = function() {
    return p(this).parent;
};

Np.appendChild = function(child) {
    p(this).children.push(child);
    var cp = p(child);
    if (cp.parent)
        cp.parent.removeChild(child);
    cp.parent = this;
    return child;
};
</code></pre>
<p>Because <code>p</code> is in scope not only within the <code>Node</code> constructor but also
within <code>Node</code> methods, we can finally avoid redefining methods every time
the <code>Node</code> constructor is called.</p>
<p>Now, you might be wondering how you can restrict access to <code>p</code> so that no
untrusted code is able to call it. The answer is to use your favorite
module pattern, be it CommonJS, AMD <code>define</code>, or even the old
Immediately-Invoked Function Expression:</p>
<pre><code class="language-js">var Node = (function() {
    var p = require(&quot;private&quot;).makeAccessor();

    function Node() {
        p(this).children = [];
    }

    var Np = Node.prototype;

    Np.getParent = function() {
        return p(this).parent;
    };

    Np.appendChild = function(child) {
        p(this).children.push(child);
        var cp = p(child);
        if (cp.parent)
            cp.parent.removeChild(child);
        cp.parent = this;
        return child;
    };

    return Node;
}());

var parent = new Node;
var child = new Node;
parent.appendChild(child);
assert.strictEqual(child.getParent(), parent);
</code></pre>
<p>Because this version of <code>p</code> never leaks from the enclosing function scope,
only <code>Node</code> objects have access to it.</p>
<p>So, you see, the claim I made at the beginning of this README remains
true:</p>
<blockquote>
<p>In JavaScript, the only data that are truly private are local variables
whose values do not <em>leak</em> from the scope in which they were defined.</p>
</blockquote>
<p>It just so happens that closure privacy is sufficient to implement a
privacy model similar to that provided by other languages.</p><footer><div class="footer"> </div></footer></body></html>